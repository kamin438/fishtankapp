{"ast":null,"code":"import { debounce } from '../debounce.js';\nimport { scrollable, dataPolarisTopBar } from '../../components/shared.js';\nimport { stackedContent } from '../breakpoints.js';\nimport { getRectForNode } from '../geometry.js';\nimport { tokens } from '../../tokens/tokens.js';\nconst SIXTY_FPS = 1000 / 60;\n\nclass StickyManager {\n  constructor(container) {\n    this.stickyItems = [];\n    this.stuckItems = [];\n    this.container = null;\n    this.topBarOffset = 0;\n    this.handleResize = debounce(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n    this.handleScroll = debounce(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n\n    if (container) {\n      this.setContainer(container);\n    }\n  }\n\n  registerStickyItem(stickyItem) {\n    this.stickyItems.push(stickyItem);\n  }\n\n  unregisterStickyItem(nodeToRemove) {\n    const nodeIndex = this.stickyItems.findIndex(_ref => {\n      let {\n        stickyNode\n      } = _ref;\n      return nodeToRemove === stickyNode;\n    });\n    this.stickyItems.splice(nodeIndex, 1);\n  }\n\n  setContainer(el) {\n    this.container = el;\n\n    if (isDocument(el)) {\n      this.setTopBarOffset(el);\n    }\n\n    this.container.addEventListener('scroll', this.handleScroll);\n    window.addEventListener('resize', this.handleResize);\n    this.manageStickyItems();\n  }\n\n  removeScrollListener() {\n    if (this.container) {\n      this.container.removeEventListener('scroll', this.handleScroll);\n      window.removeEventListener('resize', this.handleResize);\n    }\n  }\n\n  manageStickyItems() {\n    if (this.stickyItems.length <= 0) {\n      return;\n    }\n\n    const scrollTop = this.container ? scrollTopFor(this.container) : 0;\n    const containerTop = getRectForNode(this.container).top + this.topBarOffset;\n    this.stickyItems.forEach(stickyItem => {\n      const {\n        handlePositioning\n      } = stickyItem;\n      const {\n        sticky,\n        top,\n        left,\n        width\n      } = this.evaluateStickyItem(stickyItem, scrollTop, containerTop);\n      this.updateStuckItems(stickyItem, sticky);\n      handlePositioning(sticky, top, left, width);\n    });\n  }\n\n  evaluateStickyItem(stickyItem, scrollTop, containerTop) {\n    const {\n      stickyNode,\n      placeHolderNode,\n      boundingElement,\n      offset,\n      disableWhenStacked\n    } = stickyItem;\n\n    if (disableWhenStacked && stackedContent().matches) {\n      return {\n        sticky: false,\n        top: 0,\n        left: 0,\n        width: 'auto'\n      };\n    }\n\n    const stickyOffset = offset ? this.getOffset(stickyNode) + parseInt(tokens.spacing['5'], 10) : this.getOffset(stickyNode);\n    const scrollPosition = scrollTop + stickyOffset;\n    const placeHolderNodeCurrentTop = placeHolderNode.getBoundingClientRect().top - containerTop + scrollTop;\n    const top = containerTop + stickyOffset;\n    const width = placeHolderNode.getBoundingClientRect().width;\n    const left = placeHolderNode.getBoundingClientRect().left;\n    let sticky;\n\n    if (boundingElement == null) {\n      sticky = scrollPosition >= placeHolderNodeCurrentTop;\n    } else {\n      var _stickyNode$firstElem;\n\n      const stickyItemHeight = stickyNode.getBoundingClientRect().height || ((_stickyNode$firstElem = stickyNode.firstElementChild) === null || _stickyNode$firstElem === void 0 ? void 0 : _stickyNode$firstElem.getBoundingClientRect().height) || 0;\n      const stickyItemBottomPosition = boundingElement.getBoundingClientRect().bottom - stickyItemHeight + scrollTop - containerTop;\n      sticky = scrollPosition >= placeHolderNodeCurrentTop && scrollPosition < stickyItemBottomPosition;\n    }\n\n    return {\n      sticky,\n      top,\n      left,\n      width\n    };\n  }\n\n  updateStuckItems(item, sticky) {\n    const {\n      stickyNode\n    } = item;\n\n    if (sticky && !this.isNodeStuck(stickyNode)) {\n      this.addStuckItem(item);\n    } else if (!sticky && this.isNodeStuck(stickyNode)) {\n      this.removeStuckItem(item);\n    }\n  }\n\n  addStuckItem(stickyItem) {\n    this.stuckItems.push(stickyItem);\n  }\n\n  removeStuckItem(stickyItem) {\n    const {\n      stickyNode: nodeToRemove\n    } = stickyItem;\n    const nodeIndex = this.stuckItems.findIndex(_ref2 => {\n      let {\n        stickyNode\n      } = _ref2;\n      return nodeToRemove === stickyNode;\n    });\n    this.stuckItems.splice(nodeIndex, 1);\n  }\n\n  getOffset(node) {\n    if (this.stuckItems.length === 0) {\n      return 0;\n    }\n\n    let offset = 0;\n    let count = 0;\n    const stuckNodesLength = this.stuckItems.length;\n    const nodeRect = getRectForNode(node);\n\n    while (count < stuckNodesLength) {\n      const stuckNode = this.stuckItems[count].stickyNode;\n\n      if (stuckNode !== node) {\n        const stuckNodeRect = getRectForNode(stuckNode);\n\n        if (!horizontallyOverlaps(nodeRect, stuckNodeRect)) {\n          offset += getRectForNode(stuckNode).height;\n        }\n      } else {\n        break;\n      }\n\n      count++;\n    }\n\n    return offset;\n  }\n\n  isNodeStuck(node) {\n    const nodeFound = this.stuckItems.findIndex(_ref3 => {\n      let {\n        stickyNode\n      } = _ref3;\n      return node === stickyNode;\n    });\n    return nodeFound >= 0;\n  }\n\n  setTopBarOffset(container) {\n    const topbarElement = container.querySelector(`:not(${scrollable.selector}) ${dataPolarisTopBar.selector}`);\n    this.topBarOffset = topbarElement ? topbarElement.clientHeight : 0;\n  }\n\n}\n\nfunction isDocument(node) {\n  return node === document;\n}\n\nfunction scrollTopFor(container) {\n  return isDocument(container) ? document.body.scrollTop || document.documentElement.scrollTop : container.scrollTop;\n}\n\nfunction horizontallyOverlaps(rect1, rect2) {\n  const rect1Left = rect1.left;\n  const rect1Right = rect1.left + rect1.width;\n  const rect2Left = rect2.left;\n  const rect2Right = rect2.left + rect2.width;\n  return rect2Right < rect1Left || rect1Right < rect2Left;\n}\n\nexport { StickyManager };","map":{"version":3,"names":["debounce","scrollable","dataPolarisTopBar","stackedContent","getRectForNode","tokens","SIXTY_FPS","StickyManager","constructor","container","stickyItems","stuckItems","topBarOffset","handleResize","manageStickyItems","leading","trailing","maxWait","handleScroll","setContainer","registerStickyItem","stickyItem","push","unregisterStickyItem","nodeToRemove","nodeIndex","findIndex","stickyNode","splice","el","isDocument","setTopBarOffset","addEventListener","window","removeScrollListener","removeEventListener","length","scrollTop","scrollTopFor","containerTop","top","forEach","handlePositioning","sticky","left","width","evaluateStickyItem","updateStuckItems","placeHolderNode","boundingElement","offset","disableWhenStacked","matches","stickyOffset","getOffset","parseInt","spacing","scrollPosition","placeHolderNodeCurrentTop","getBoundingClientRect","_stickyNode$firstElem","stickyItemHeight","height","firstElementChild","stickyItemBottomPosition","bottom","item","isNodeStuck","addStuckItem","removeStuckItem","node","count","stuckNodesLength","nodeRect","stuckNode","stuckNodeRect","horizontallyOverlaps","nodeFound","topbarElement","querySelector","selector","clientHeight","document","body","documentElement","rect1","rect2","rect1Left","rect1Right","rect2Left","rect2Right"],"sources":["/Users/kevalamin/Projects/fishtankapp/client/node_modules/@shopify/polaris/build/esm/utilities/sticky-manager/sticky-manager.js"],"sourcesContent":["import { debounce } from '../debounce.js';\nimport { scrollable, dataPolarisTopBar } from '../../components/shared.js';\nimport { stackedContent } from '../breakpoints.js';\nimport { getRectForNode } from '../geometry.js';\nimport { tokens } from '../../tokens/tokens.js';\n\nconst SIXTY_FPS = 1000 / 60;\nclass StickyManager {\n  constructor(container) {\n    this.stickyItems = [];\n    this.stuckItems = [];\n    this.container = null;\n    this.topBarOffset = 0;\n    this.handleResize = debounce(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n    this.handleScroll = debounce(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n\n    if (container) {\n      this.setContainer(container);\n    }\n  }\n\n  registerStickyItem(stickyItem) {\n    this.stickyItems.push(stickyItem);\n  }\n\n  unregisterStickyItem(nodeToRemove) {\n    const nodeIndex = this.stickyItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stickyItems.splice(nodeIndex, 1);\n  }\n\n  setContainer(el) {\n    this.container = el;\n\n    if (isDocument(el)) {\n      this.setTopBarOffset(el);\n    }\n\n    this.container.addEventListener('scroll', this.handleScroll);\n    window.addEventListener('resize', this.handleResize);\n    this.manageStickyItems();\n  }\n\n  removeScrollListener() {\n    if (this.container) {\n      this.container.removeEventListener('scroll', this.handleScroll);\n      window.removeEventListener('resize', this.handleResize);\n    }\n  }\n\n  manageStickyItems() {\n    if (this.stickyItems.length <= 0) {\n      return;\n    }\n\n    const scrollTop = this.container ? scrollTopFor(this.container) : 0;\n    const containerTop = getRectForNode(this.container).top + this.topBarOffset;\n    this.stickyItems.forEach(stickyItem => {\n      const {\n        handlePositioning\n      } = stickyItem;\n      const {\n        sticky,\n        top,\n        left,\n        width\n      } = this.evaluateStickyItem(stickyItem, scrollTop, containerTop);\n      this.updateStuckItems(stickyItem, sticky);\n      handlePositioning(sticky, top, left, width);\n    });\n  }\n\n  evaluateStickyItem(stickyItem, scrollTop, containerTop) {\n    const {\n      stickyNode,\n      placeHolderNode,\n      boundingElement,\n      offset,\n      disableWhenStacked\n    } = stickyItem;\n\n    if (disableWhenStacked && stackedContent().matches) {\n      return {\n        sticky: false,\n        top: 0,\n        left: 0,\n        width: 'auto'\n      };\n    }\n\n    const stickyOffset = offset ? this.getOffset(stickyNode) + parseInt(tokens.spacing['5'], 10) : this.getOffset(stickyNode);\n    const scrollPosition = scrollTop + stickyOffset;\n    const placeHolderNodeCurrentTop = placeHolderNode.getBoundingClientRect().top - containerTop + scrollTop;\n    const top = containerTop + stickyOffset;\n    const width = placeHolderNode.getBoundingClientRect().width;\n    const left = placeHolderNode.getBoundingClientRect().left;\n    let sticky;\n\n    if (boundingElement == null) {\n      sticky = scrollPosition >= placeHolderNodeCurrentTop;\n    } else {\n      var _stickyNode$firstElem;\n\n      const stickyItemHeight = stickyNode.getBoundingClientRect().height || ((_stickyNode$firstElem = stickyNode.firstElementChild) === null || _stickyNode$firstElem === void 0 ? void 0 : _stickyNode$firstElem.getBoundingClientRect().height) || 0;\n      const stickyItemBottomPosition = boundingElement.getBoundingClientRect().bottom - stickyItemHeight + scrollTop - containerTop;\n      sticky = scrollPosition >= placeHolderNodeCurrentTop && scrollPosition < stickyItemBottomPosition;\n    }\n\n    return {\n      sticky,\n      top,\n      left,\n      width\n    };\n  }\n\n  updateStuckItems(item, sticky) {\n    const {\n      stickyNode\n    } = item;\n\n    if (sticky && !this.isNodeStuck(stickyNode)) {\n      this.addStuckItem(item);\n    } else if (!sticky && this.isNodeStuck(stickyNode)) {\n      this.removeStuckItem(item);\n    }\n  }\n\n  addStuckItem(stickyItem) {\n    this.stuckItems.push(stickyItem);\n  }\n\n  removeStuckItem(stickyItem) {\n    const {\n      stickyNode: nodeToRemove\n    } = stickyItem;\n    const nodeIndex = this.stuckItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stuckItems.splice(nodeIndex, 1);\n  }\n\n  getOffset(node) {\n    if (this.stuckItems.length === 0) {\n      return 0;\n    }\n\n    let offset = 0;\n    let count = 0;\n    const stuckNodesLength = this.stuckItems.length;\n    const nodeRect = getRectForNode(node);\n\n    while (count < stuckNodesLength) {\n      const stuckNode = this.stuckItems[count].stickyNode;\n\n      if (stuckNode !== node) {\n        const stuckNodeRect = getRectForNode(stuckNode);\n\n        if (!horizontallyOverlaps(nodeRect, stuckNodeRect)) {\n          offset += getRectForNode(stuckNode).height;\n        }\n      } else {\n        break;\n      }\n\n      count++;\n    }\n\n    return offset;\n  }\n\n  isNodeStuck(node) {\n    const nodeFound = this.stuckItems.findIndex(({\n      stickyNode\n    }) => node === stickyNode);\n    return nodeFound >= 0;\n  }\n\n  setTopBarOffset(container) {\n    const topbarElement = container.querySelector(`:not(${scrollable.selector}) ${dataPolarisTopBar.selector}`);\n    this.topBarOffset = topbarElement ? topbarElement.clientHeight : 0;\n  }\n\n}\n\nfunction isDocument(node) {\n  return node === document;\n}\n\nfunction scrollTopFor(container) {\n  return isDocument(container) ? document.body.scrollTop || document.documentElement.scrollTop : container.scrollTop;\n}\n\nfunction horizontallyOverlaps(rect1, rect2) {\n  const rect1Left = rect1.left;\n  const rect1Right = rect1.left + rect1.width;\n  const rect2Left = rect2.left;\n  const rect2Right = rect2.left + rect2.width;\n  return rect2Right < rect1Left || rect1Right < rect2Left;\n}\n\nexport { StickyManager };\n"],"mappings":"AAAA,SAASA,QAAT,QAAyB,gBAAzB;AACA,SAASC,UAAT,EAAqBC,iBAArB,QAA8C,4BAA9C;AACA,SAASC,cAAT,QAA+B,mBAA/B;AACA,SAASC,cAAT,QAA+B,gBAA/B;AACA,SAASC,MAAT,QAAuB,wBAAvB;AAEA,MAAMC,SAAS,GAAG,OAAO,EAAzB;;AACA,MAAMC,aAAN,CAAoB;EAClBC,WAAW,CAACC,SAAD,EAAY;IACrB,KAAKC,WAAL,GAAmB,EAAnB;IACA,KAAKC,UAAL,GAAkB,EAAlB;IACA,KAAKF,SAAL,GAAiB,IAAjB;IACA,KAAKG,YAAL,GAAoB,CAApB;IACA,KAAKC,YAAL,GAAoBb,QAAQ,CAAC,MAAM;MACjC,KAAKc,iBAAL;IACD,CAF2B,EAEzBR,SAFyB,EAEd;MACZS,OAAO,EAAE,IADG;MAEZC,QAAQ,EAAE,IAFE;MAGZC,OAAO,EAAEX;IAHG,CAFc,CAA5B;IAOA,KAAKY,YAAL,GAAoBlB,QAAQ,CAAC,MAAM;MACjC,KAAKc,iBAAL;IACD,CAF2B,EAEzBR,SAFyB,EAEd;MACZS,OAAO,EAAE,IADG;MAEZC,QAAQ,EAAE,IAFE;MAGZC,OAAO,EAAEX;IAHG,CAFc,CAA5B;;IAQA,IAAIG,SAAJ,EAAe;MACb,KAAKU,YAAL,CAAkBV,SAAlB;IACD;EACF;;EAEDW,kBAAkB,CAACC,UAAD,EAAa;IAC7B,KAAKX,WAAL,CAAiBY,IAAjB,CAAsBD,UAAtB;EACD;;EAEDE,oBAAoB,CAACC,YAAD,EAAe;IACjC,MAAMC,SAAS,GAAG,KAAKf,WAAL,CAAiBgB,SAAjB,CAA2B;MAAA,IAAC;QAC5CC;MAD4C,CAAD;MAAA,OAEvCH,YAAY,KAAKG,UAFsB;IAAA,CAA3B,CAAlB;IAGA,KAAKjB,WAAL,CAAiBkB,MAAjB,CAAwBH,SAAxB,EAAmC,CAAnC;EACD;;EAEDN,YAAY,CAACU,EAAD,EAAK;IACf,KAAKpB,SAAL,GAAiBoB,EAAjB;;IAEA,IAAIC,UAAU,CAACD,EAAD,CAAd,EAAoB;MAClB,KAAKE,eAAL,CAAqBF,EAArB;IACD;;IAED,KAAKpB,SAAL,CAAeuB,gBAAf,CAAgC,QAAhC,EAA0C,KAAKd,YAA/C;IACAe,MAAM,CAACD,gBAAP,CAAwB,QAAxB,EAAkC,KAAKnB,YAAvC;IACA,KAAKC,iBAAL;EACD;;EAEDoB,oBAAoB,GAAG;IACrB,IAAI,KAAKzB,SAAT,EAAoB;MAClB,KAAKA,SAAL,CAAe0B,mBAAf,CAAmC,QAAnC,EAA6C,KAAKjB,YAAlD;MACAe,MAAM,CAACE,mBAAP,CAA2B,QAA3B,EAAqC,KAAKtB,YAA1C;IACD;EACF;;EAEDC,iBAAiB,GAAG;IAClB,IAAI,KAAKJ,WAAL,CAAiB0B,MAAjB,IAA2B,CAA/B,EAAkC;MAChC;IACD;;IAED,MAAMC,SAAS,GAAG,KAAK5B,SAAL,GAAiB6B,YAAY,CAAC,KAAK7B,SAAN,CAA7B,GAAgD,CAAlE;IACA,MAAM8B,YAAY,GAAGnC,cAAc,CAAC,KAAKK,SAAN,CAAd,CAA+B+B,GAA/B,GAAqC,KAAK5B,YAA/D;IACA,KAAKF,WAAL,CAAiB+B,OAAjB,CAAyBpB,UAAU,IAAI;MACrC,MAAM;QACJqB;MADI,IAEFrB,UAFJ;MAGA,MAAM;QACJsB,MADI;QAEJH,GAFI;QAGJI,IAHI;QAIJC;MAJI,IAKF,KAAKC,kBAAL,CAAwBzB,UAAxB,EAAoCgB,SAApC,EAA+CE,YAA/C,CALJ;MAMA,KAAKQ,gBAAL,CAAsB1B,UAAtB,EAAkCsB,MAAlC;MACAD,iBAAiB,CAACC,MAAD,EAASH,GAAT,EAAcI,IAAd,EAAoBC,KAApB,CAAjB;IACD,CAZD;EAaD;;EAEDC,kBAAkB,CAACzB,UAAD,EAAagB,SAAb,EAAwBE,YAAxB,EAAsC;IACtD,MAAM;MACJZ,UADI;MAEJqB,eAFI;MAGJC,eAHI;MAIJC,MAJI;MAKJC;IALI,IAMF9B,UANJ;;IAQA,IAAI8B,kBAAkB,IAAIhD,cAAc,GAAGiD,OAA3C,EAAoD;MAClD,OAAO;QACLT,MAAM,EAAE,KADH;QAELH,GAAG,EAAE,CAFA;QAGLI,IAAI,EAAE,CAHD;QAILC,KAAK,EAAE;MAJF,CAAP;IAMD;;IAED,MAAMQ,YAAY,GAAGH,MAAM,GAAG,KAAKI,SAAL,CAAe3B,UAAf,IAA6B4B,QAAQ,CAAClD,MAAM,CAACmD,OAAP,CAAe,GAAf,CAAD,EAAsB,EAAtB,CAAxC,GAAoE,KAAKF,SAAL,CAAe3B,UAAf,CAA/F;IACA,MAAM8B,cAAc,GAAGpB,SAAS,GAAGgB,YAAnC;IACA,MAAMK,yBAAyB,GAAGV,eAAe,CAACW,qBAAhB,GAAwCnB,GAAxC,GAA8CD,YAA9C,GAA6DF,SAA/F;IACA,MAAMG,GAAG,GAAGD,YAAY,GAAGc,YAA3B;IACA,MAAMR,KAAK,GAAGG,eAAe,CAACW,qBAAhB,GAAwCd,KAAtD;IACA,MAAMD,IAAI,GAAGI,eAAe,CAACW,qBAAhB,GAAwCf,IAArD;IACA,IAAID,MAAJ;;IAEA,IAAIM,eAAe,IAAI,IAAvB,EAA6B;MAC3BN,MAAM,GAAGc,cAAc,IAAIC,yBAA3B;IACD,CAFD,MAEO;MACL,IAAIE,qBAAJ;;MAEA,MAAMC,gBAAgB,GAAGlC,UAAU,CAACgC,qBAAX,GAAmCG,MAAnC,KAA8C,CAACF,qBAAqB,GAAGjC,UAAU,CAACoC,iBAApC,MAA2D,IAA3D,IAAmEH,qBAAqB,KAAK,KAAK,CAAlG,GAAsG,KAAK,CAA3G,GAA+GA,qBAAqB,CAACD,qBAAtB,GAA8CG,MAA3M,KAAsN,CAA/O;MACA,MAAME,wBAAwB,GAAGf,eAAe,CAACU,qBAAhB,GAAwCM,MAAxC,GAAiDJ,gBAAjD,GAAoExB,SAApE,GAAgFE,YAAjH;MACAI,MAAM,GAAGc,cAAc,IAAIC,yBAAlB,IAA+CD,cAAc,GAAGO,wBAAzE;IACD;;IAED,OAAO;MACLrB,MADK;MAELH,GAFK;MAGLI,IAHK;MAILC;IAJK,CAAP;EAMD;;EAEDE,gBAAgB,CAACmB,IAAD,EAAOvB,MAAP,EAAe;IAC7B,MAAM;MACJhB;IADI,IAEFuC,IAFJ;;IAIA,IAAIvB,MAAM,IAAI,CAAC,KAAKwB,WAAL,CAAiBxC,UAAjB,CAAf,EAA6C;MAC3C,KAAKyC,YAAL,CAAkBF,IAAlB;IACD,CAFD,MAEO,IAAI,CAACvB,MAAD,IAAW,KAAKwB,WAAL,CAAiBxC,UAAjB,CAAf,EAA6C;MAClD,KAAK0C,eAAL,CAAqBH,IAArB;IACD;EACF;;EAEDE,YAAY,CAAC/C,UAAD,EAAa;IACvB,KAAKV,UAAL,CAAgBW,IAAhB,CAAqBD,UAArB;EACD;;EAEDgD,eAAe,CAAChD,UAAD,EAAa;IAC1B,MAAM;MACJM,UAAU,EAAEH;IADR,IAEFH,UAFJ;IAGA,MAAMI,SAAS,GAAG,KAAKd,UAAL,CAAgBe,SAAhB,CAA0B;MAAA,IAAC;QAC3CC;MAD2C,CAAD;MAAA,OAEtCH,YAAY,KAAKG,UAFqB;IAAA,CAA1B,CAAlB;IAGA,KAAKhB,UAAL,CAAgBiB,MAAhB,CAAuBH,SAAvB,EAAkC,CAAlC;EACD;;EAED6B,SAAS,CAACgB,IAAD,EAAO;IACd,IAAI,KAAK3D,UAAL,CAAgByB,MAAhB,KAA2B,CAA/B,EAAkC;MAChC,OAAO,CAAP;IACD;;IAED,IAAIc,MAAM,GAAG,CAAb;IACA,IAAIqB,KAAK,GAAG,CAAZ;IACA,MAAMC,gBAAgB,GAAG,KAAK7D,UAAL,CAAgByB,MAAzC;IACA,MAAMqC,QAAQ,GAAGrE,cAAc,CAACkE,IAAD,CAA/B;;IAEA,OAAOC,KAAK,GAAGC,gBAAf,EAAiC;MAC/B,MAAME,SAAS,GAAG,KAAK/D,UAAL,CAAgB4D,KAAhB,EAAuB5C,UAAzC;;MAEA,IAAI+C,SAAS,KAAKJ,IAAlB,EAAwB;QACtB,MAAMK,aAAa,GAAGvE,cAAc,CAACsE,SAAD,CAApC;;QAEA,IAAI,CAACE,oBAAoB,CAACH,QAAD,EAAWE,aAAX,CAAzB,EAAoD;UAClDzB,MAAM,IAAI9C,cAAc,CAACsE,SAAD,CAAd,CAA0BZ,MAApC;QACD;MACF,CAND,MAMO;QACL;MACD;;MAEDS,KAAK;IACN;;IAED,OAAOrB,MAAP;EACD;;EAEDiB,WAAW,CAACG,IAAD,EAAO;IAChB,MAAMO,SAAS,GAAG,KAAKlE,UAAL,CAAgBe,SAAhB,CAA0B;MAAA,IAAC;QAC3CC;MAD2C,CAAD;MAAA,OAEtC2C,IAAI,KAAK3C,UAF6B;IAAA,CAA1B,CAAlB;IAGA,OAAOkD,SAAS,IAAI,CAApB;EACD;;EAED9C,eAAe,CAACtB,SAAD,EAAY;IACzB,MAAMqE,aAAa,GAAGrE,SAAS,CAACsE,aAAV,CAAyB,QAAO9E,UAAU,CAAC+E,QAAS,KAAI9E,iBAAiB,CAAC8E,QAAS,EAAnF,CAAtB;IACA,KAAKpE,YAAL,GAAoBkE,aAAa,GAAGA,aAAa,CAACG,YAAjB,GAAgC,CAAjE;EACD;;AA3LiB;;AA+LpB,SAASnD,UAAT,CAAoBwC,IAApB,EAA0B;EACxB,OAAOA,IAAI,KAAKY,QAAhB;AACD;;AAED,SAAS5C,YAAT,CAAsB7B,SAAtB,EAAiC;EAC/B,OAAOqB,UAAU,CAACrB,SAAD,CAAV,GAAwByE,QAAQ,CAACC,IAAT,CAAc9C,SAAd,IAA2B6C,QAAQ,CAACE,eAAT,CAAyB/C,SAA5E,GAAwF5B,SAAS,CAAC4B,SAAzG;AACD;;AAED,SAASuC,oBAAT,CAA8BS,KAA9B,EAAqCC,KAArC,EAA4C;EAC1C,MAAMC,SAAS,GAAGF,KAAK,CAACzC,IAAxB;EACA,MAAM4C,UAAU,GAAGH,KAAK,CAACzC,IAAN,GAAayC,KAAK,CAACxC,KAAtC;EACA,MAAM4C,SAAS,GAAGH,KAAK,CAAC1C,IAAxB;EACA,MAAM8C,UAAU,GAAGJ,KAAK,CAAC1C,IAAN,GAAa0C,KAAK,CAACzC,KAAtC;EACA,OAAO6C,UAAU,GAAGH,SAAb,IAA0BC,UAAU,GAAGC,SAA9C;AACD;;AAED,SAASlF,aAAT"},"metadata":{},"sourceType":"module"}